<!--
This HTML is used as an aid for populating the graph Database
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>UTech Graph Editor — Full</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0f1113;--panel:#0b0c0e;--muted:#9aa3ad;--accent:#00ccff}
  html,body{height:100%;margin:0;background:var(--bg);color:#eee;font-family:Inter,Segoe UI,Arial,sans-serif}
  #toolbar{position:fixed;left:0;right:0;top:0;height:48px;background:var(--panel);display:flex;gap:8px;align-items:center;padding:6px 8px;z-index:40}
  button,select,input {background:#111;border:1px solid #222;color:#eee;padding:6px 8px;border-radius:6px}
  #canvasWrap{position:absolute;top:56px;bottom:0;left:0;right:320px;overflow:auto}
  canvas{display:block; background:#222; cursor:crosshair}
  #side{position:fixed;right:0;top:56px;bottom:0;width:320px; background:#091018;padding:10px;overflow:auto;border-left:1px solid #111}
  .small{font-size:12px;color:var(--muted)}
  .status{margin-left:8px;font-weight:600}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  label.small{width:95px}
  .legend{display:flex;gap:8px;margin-top:8px}
  .chip{padding:6px;border-radius:6px}
</style>
</head>
<body>

<div id="toolbar">
  <button id="btnAdd">Add Node (A)</button>
  <button id="btnEdge">Add Edge (E)</button>
  <button id="btnMove">Move Node (M)</button>
  <button id="btnEditEdge">Edit Edge (Ctrl+E)</button>
  <button id="btnDelete">Delete (Del)</button>
  <button id="btnUndo">Undo (Ctrl+Z)</button>
  <button id="btnRedo">Redo (Ctrl+Y)</button>

  <select id="nodeType">
    <option value="walkway">Walkway</option>
    <option value="building">Building</option>
    <option value="gate">Gate</option>
  </select>

  <button id="btnExportJS">Export JS (Ctrl+S)</button>
  <button id="btnExportJSON">Export JSON</button>
  <button id="btnImportJS">Import JS</button>

  <span class="status" id="status">Loading resources…</span>
</div>

<div id="canvasWrap">
  <canvas id="mapCanvas"></canvas>
</div>

<div id="side">
  <div class="small">Map controls</div>
  <div class="row">
    <label class="small">Grid</label>
    <button id="toggleGrid">Toggle Grid (G)</button>
  </div>

  <div class="row">
    <label class="small">Snap</label>
    <button id="toggleSnap">Hard Snap: ON</button>
  </div>

  <div class="row">
    <label class="small">Labels</label>
    <button id="toggleLabels">Hide Labels (H)</button>
  </div>

  <div class="row">
    <label class="small">Zoom</label>
    <button id="zoomIn">+</button>
    <button id="zoomOut">-</button>
    <div style="margin-left:8px" class="small">Use mousewheel or touchpad</div>
  </div>

  <hr style="border:0;border-top:1px solid #111;margin:12px 0">

  <div class="small">Import / Quick Parse</div>
  <textarea id="importArea" style="width:100%;height:120px;background:#06111a;color:#ddd;border:1px solid #0b2230;padding:8px;margin-top:8px"
    placeholder="Paste graphDatabase.js content here (or exported JSON)"></textarea>
  <div class="row">
    <button id="btnParseJS">Parse & Import JS</button>
    <button id="btnLoadJSON">Load JSON</button>
  </div>
  <div class="small" style="margin-top:12px">Nodes & Edges</div>
  <div id="stats" class="small">0 nodes • 0 edges</div>

  <div style="margin-top:12px">
    <div class="small">Legend</div>
    <div class="legend">
      <div class="chip" style="background:#ffcc00;color:#111;padding:6px;border-radius:6px">Building</div>
      <div class="chip" style="background:#00cccc;color:#011">Walkway</div>
      <div class="chip" style="background:#ff8a00;color:#111">Gate</div>
    </div>
  </div>

  <hr style="border:0;border-top:1px solid #111;margin:12px 0">
  <div class="small">Shortcuts</div>
  <ul class="small">
    <li>A Add node | E Add edge | M Move node</li>
    <li>Shift+Click duplicate | Arrows nudge | WASD pan</li>
    <li>Ctrl+Z Undo | Ctrl+Y Redo | Ctrl+S Export JS</li>
    <li>G Toggle grid | H Hide labels | R Rename selected</li>
  </ul>
</div>

<script>
/*
 Full-featured graph editor script
 - Uses OpenCV.js for hard snapping (path pixel detection)
 - Full history stack (deep snapshots)
 - JS parser for importing GraphNode definitions
 - Smart naming using simple region detection
 - Multi-control-point edges (waypoint curves)
*/

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

let mapImg = new Image();
mapImg.src = 'utech_map.png'; // put this image next to the HTML file

// Canvas transform and interaction state
let scale = 1, offsetX = 0, offsetY = 0;
let draggingCanvas = false, lastPan = null;

// Application state
let nodes = [];         // {id,name,type,x,y}
let edges = [];         // {id,a,b,controlPoints:[{x,y},...]}
let selectedNode = null;
let selectedEdge = null;
let mode = 'addNode';   // addNode, addEdge, moveNode, editEdge, delete
let nodeTypeSelect = document.getElementById('nodeType');
let showGrid = false;
let showLabels = true;
let hardSnap = true;
let cvReady = false;
let pathMask = null; // binary mask from OpenCV

// History (full snapshots)
let history = [];
let historyIndex = -1;
const MAX_HISTORY = 200;

// Auto counters
let counters = { walkway: 0, building: 0, gate: 0 };

// Node id helper
function genId(prefix='n'){ return prefix + '_' + Math.random().toString(36).slice(2,9); }

// Utility: deep snapshot push
function pushHistory(actionName = '') {
    // Keep a copy of nodes & edges
    const snap = {
        nodes: JSON.parse(JSON.stringify(nodes)),
        edges: JSON.parse(JSON.stringify(edges)),
        counters: JSON.parse(JSON.stringify(counters)),
        mode, actionName,
    };
    // Trim redo states
    history = history.slice(0, historyIndex + 1);
    history.push(snap);
    if (history.length > MAX_HISTORY) history.shift();
    historyIndex = history.length - 1;
    updateStatus(`History: ${historyIndex+1}/${history.length}`);
}
function undo() {
    if (historyIndex <= 0) { updateStatus('Nothing to undo.'); return; }
    historyIndex--;
    restoreHistory();
}
function redo() {
    if (historyIndex >= history.length - 1) { updateStatus('Nothing to redo.'); return; }
    historyIndex++;
    restoreHistory();
}
function restoreHistory() {
    const snap = history[historyIndex];
    nodes = JSON.parse(JSON.stringify(snap.nodes));
    edges = JSON.parse(JSON.stringify(snap.edges));
    counters = JSON.parse(JSON.stringify(snap.counters));
    mode = snap.mode;
    selectedNode = null;
    selectedEdge = null;
    draw();
    updateStats();
    updateStatus(`Restored: ${historyIndex+1}/${history.length} (${snap.actionName || 'snapshot'})`);
}

// Status & stats
const statusElem = document.getElementById('status');
function updateStatus(t='') { statusElem.textContent = t; }
function updateStats() { document.getElementById('stats').textContent = `${nodes.length} nodes • ${edges.length} edges`; }

// Canvas sizing & drawing
function resizeCanvas() {
    canvas.width = mapImg.width;
    canvas.height = mapImg.height;
    draw();
}
mapImg.onload = async () => {
    resizeCanvas();
    draw();
    updateStatus('Map loaded. Initializing OpenCV…');
    // Load mask after opencv ready
    waitForCV().then(() => {
        createPathMask();
    });
};

// Transform helpers
function toCanvasCoords(screenX, screenY) {
    // account for canvas being scrolled inside wrapper
    const rect = canvas.getBoundingClientRect();
    const x = (screenX - rect.left - offsetX) / scale;
    const y = (screenY - rect.top - offsetY) / scale;
    return { x: Math.round(x), y: Math.round(y) };
}
function fromCanvasCoords(x,y) {
    return { sx: x*scale + offsetX, sy: y*scale + offsetY };
}

function clearAndTransform() {
    // No CSS transforms; draw map at transform
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.scale(scale, scale);
    ctx.translate(offsetX/scale, offsetY/scale);
}

function draw() {
    if (!mapImg.width) return;
    // reset transform
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw map
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.drawImage(mapImg, 0, 0);
    // optional grid
    if (showGrid) {
        const step = 50;
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.lineWidth = 1/scale;
        for (let x=0;x<canvas.width;x+=step) {
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
        }
        for (let y=0;y<canvas.height;y+=step) {
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
        }
    }

    // draw edges
    edges.forEach(edge => {
        const a = findNodeById(edge.a), b = findNodeById(edge.b);
        if (!a || !b) return;
        ctx.lineWidth = 2/scale;
        ctx.strokeStyle = '#00ccff';
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        if (edge.controlPoints && edge.controlPoints.length) {
            // draw curve through control points
            const cp = edge.controlPoints;
            // simple drawing: connect with quadratic/cubic based on number
            let pts = [ {x:a.x,y:a.y}, ...cp, {x:b.x,y:b.y} ];
            // draw smooth polyline
            for (let i=1;i<pts.length;i++){
                const p0=pts[i-1], p1=pts[i];
                ctx.lineTo(p1.x,p1.y);
            }
        } else {
            ctx.lineTo(b.x, b.y);
        }
        ctx.stroke();

        // draw control points
        if (edge.controlPoints) {
            edge.controlPoints.forEach((p,pi)=>{
                ctx.fillStyle = '#ff88ff';
                ctx.beginPath(); ctx.arc(p.x,p.y,5/scale,0,Math.PI*2); ctx.fill();
            });
        }
    });

    // draw nodes
    nodes.forEach(n=>{
        let color = '#00cccc';
        if (n.type==='building') color = '#ffcc00';
        if (n.type==='gate') color = '#ff8a00';

        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(n.x, n.y, 8/scale, 0, Math.PI*2); ctx.fill();

        if (showLabels) {
            ctx.fillStyle = '#fff';
            ctx.font = `${14/scale}px sans-serif`;
            ctx.fillText(n.name, n.x + 10/scale, n.y - 10/scale);
        }
    });

    ctx.restore();
    updateStats();
}

// Find by id
function findNodeById(id) { return nodes.find(n=>n.id===id); }
function findNodeNear(x,y,px=12) {
    for (let i=0;i<nodes.length;i++){
        const n = nodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= px/scale) return n;
    }
    return null;
}

// Smart naming (4B): region detection
function smartNameFor(type, x,y) {
    const w = canvas.width, h = canvas.height;
    const leftThird = w/3, rightThird = 2*w/3;
    let region = 'central';
    if (x < leftThird) region = 'west';
    else if (x > rightThird) region = 'east';
    else if (y < h/3) region = 'north';
    else if (y > 2*h/3) region = 'south';
    counters[type]++;
    const short = type==='walkway' ? 'w' : (type==='building'?'b':'g');
    return `${region}_${short}${counters[type]}`;
}

// OpenCV integration (3B)
function waitForCV() {
    return new Promise((res,rej) => {
        if (cvReady) return res();
        // load opencv if not present
        if (typeof cv === 'undefined') {
            updateStatus('Loading OpenCV.js from CDN…');
            const s = document.createElement('script');
            s.src = 'https://docs.opencv.org/4.x/opencv.js';
            s.onload = () => { console.log('opencv loaded'); };
            s.onerror = () => { updateStatus('OpenCV failed to load'); res(); };
            document.head.appendChild(s);
            // original opencv sets cv['onRuntimeInitialized']
            let waited = 0;
            const t = setInterval(()=>{
                if (typeof cv !== 'undefined' && cv && cv.ready) {
                    clearInterval(t); cvReady=true; updateStatus('OpenCV ready'); res();
                } else {
                    waited++;
                    if (waited>80) { clearInterval(t); updateStatus('OpenCV not available'); res(); }
                }
            },200);
        } else {
            cvReady = true; res();
        }
    });
}

async function createPathMask() {
    if (!cvReady) { updateStatus('OpenCV not ready for mask'); return; }
    updateStatus('Creating path mask (OpenCV)…');
    try {
        const src = cv.imread(mapImg);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        // Use adaptive threshold to detect bright lines (paths) — tweak as needed
        let blur = new cv.Mat();
        cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
        let thresh = new cv.Mat();
        cv.adaptiveThreshold(blur, thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 21, 8);
        // morphological open to reduce noise
        let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
        cv.morphologyEx(thresh, thresh, cv.MORPH_OPEN, kernel);
        pathMask = thresh.clone();
        // clean up
        src.delete(); gray.delete(); blur.delete(); kernel.delete();
        updateStatus('Path mask created.');
    } catch (e) {
        console.error(e);
        updateStatus('Path mask failed: ' + e.message);
    }
}

// Snap to nearest path pixel (3B)
function snapToPath(x,y,searchRadius=30) {
    if (!hardSnap || !pathMask) return {x,y};
    // clamp to image bounds
    const imgW = pathMask.cols, imgH = pathMask.rows;
    const cx = Math.min(Math.max(0, Math.round(x)), imgW-1);
    const cy = Math.min(Math.max(0, Math.round(y)), imgH-1);
    // if current pixel already path (non-zero), keep
    const pix = pathMask.ucharPtr(cy, cx)[0];
    if (pix > 0) return {x:cx, y:cy};
    // search in square until radius, find nearest nonzero
    let best = null;
    for (let r=1;r<=searchRadius;r++){
        for (let dx=-r; dx<=r; dx++){
            for (let dy=-r; dy<=r; dy++){
                const nx = cx+dx, ny = cy+dy;
                if (nx<0||ny<0||nx>=imgW||ny>=imgH) continue;
                const v = pathMask.ucharPtr(ny,nx)[0];
                if (v>0) {
                    const dist = Math.hypot(dx,dy);
                    if (!best || dist < best.dist) best = {x:nx,y:ny,dist};
                }
            }
        }
        if (best) break;
    }
    if (best) return {x:best.x, y:best.y};
    return {x,y};
}

// Event handlers for canvas interactions
let pendingEdgeFrom = null;
let draggingNode = null;
let dragOffset = {x:0,y:0};

canvas.addEventListener('mousedown', (evt)=>{
    const {x,y} = toCanvasCoords(evt.clientX, evt.clientY);
    if (evt.button === 2) return; // ignore right-click
    if (evt.shiftKey && mode !== 'moveNode') {
        // duplication shortcut: duplicate node if clicked on it
        const n = findNodeNear(x,y);
        if (n) {
            const dup = {...n};
            dup.id = genId('n'); dup.x += 20; dup.y += 20;
            duplicatename(dup);
            nodes.push(dup);
            pushHistory('duplicate node');
            draw(); return;
        }
    }

    if (mode === 'addNode') {
        // smart name + hard snap
        let snapped = hardSnap ? snapToPath(x,y) : {x,y};
        const type = nodeTypeSelect.value;
        const name = smartNameFor(type, snapped.x, snapped.y);
        const nid = genId('n');
        nodes.push({ id: nid, name, type, x: snapped.x, y: snapped.y });
        pushHistory('addNode');
        draw();
        return;
    }
    if (mode === 'addEdge') {
        const n = findNodeNear(x,y);
        if (!n) { updateStatus('Click on a node to start an edge'); return; }
        if (!pendingEdgeFrom) {
            pendingEdgeFrom = n;
            updateStatus('Select target node for edge (click node)');
        } else {
            if (pendingEdgeFrom.id === n.id) {
                updateStatus('Cannot connect node to itself');
                pendingEdgeFrom = null;
                return;
            }
            // add edge
            const eid = genId('e');
            edges.push({ id: eid, a: pendingEdgeFrom.id, b: n.id, controlPoints: [] });
            pendingEdgeFrom = null;
            pushHistory('addEdge');
            draw();
        }
        return;
    }
    if (mode === 'moveNode') {
        const n = findNodeNear(x,y);
        if (n) {
            draggingNode = n;
            dragOffset.x = n.x - x;
            dragOffset.y = n.y - y;
        } else {
            // start panning canvas
            draggingCanvas = true;
            lastPan = { sx: evt.clientX, sy: evt.clientY };
        }
        return;
    }
    if (mode === 'editEdge') {
        // select an edge control point or node for editing
        // find nearest control point first
        let found = null;
        edges.forEach(edge=>{
            (edge.controlPoints||[]).forEach((p,pi)=>{
                if (Math.hypot(p.x-x, p.y-y) < 8/scale) found = { edge, index: pi };
            });
        });
        if (found) {
            // remove control point on Shift+click, else start dragging
            if (evt.shiftKey) {
                found.edge.controlPoints.splice(found.index,1);
                pushHistory('remove control point');
            } else {
                // start dragging control point (store on selectedEdge)
                selectedEdge = found.edge;
                selectedEdge.draggingControl = found.index;
            }
            draw();
            return;
        }
        // else try to pick an edge by proximity to its segment
        const edgePicked = pickEdgeNearby(x,y);
        if (edgePicked) {
            selectedEdge = edgePicked;
            updateStatus('Edge selected. Click to add a control point. Drag points to move.');
            draw();
            return;
        } else {
            selectedEdge = null;
            draw();
            updateStatus('');
        }
        return;
    }
    if (mode === 'delete') {
        // delete node or edge clicked
        const n = findNodeNear(x,y);
        if (n) {
            // remove node and edges incident
            edges = edges.filter(e => e.a !== n.id && e.b !== n.id);
            nodes = nodes.filter(m => m.id !== n.id);
            pushHistory('delete node');
            draw(); return;
        }
        const e = pickEdgeNearby(x,y);
        if (e) {
            edges = edges.filter(en => en.id !== e.id);
            pushHistory('delete edge');
            draw(); return;
        }
    }
});

// mousemove for dragging nodes or control points or panning
canvas.addEventListener('mousemove', (evt)=>{
    const p = toCanvasCoords(evt.clientX, evt.clientY);
    if (draggingNode) {
        draggingNode.x = p.x + dragOffset.x;
        draggingNode.y = p.y + dragOffset.y;
        draw();
        return;
    }
    if (draggingCanvas && lastPan) {
        const dx = evt.clientX - lastPan.sx;
        const dy = evt.clientY - lastPan.sy;
        offsetX += dx; offsetY += dy;
        lastPan = { sx: evt.clientX, sy: evt.clientY };
        draw(); return;
    }
    // edge control dragging
    if (selectedEdge && typeof selectedEdge.draggingControl === 'number') {
        const idx = selectedEdge.draggingControl;
        selectedEdge.controlPoints[idx].x = p.x;
        selectedEdge.controlPoints[idx].y = p.y;
        draw(); return;
    }
});

// mouseup finalize dragging
canvas.addEventListener('mouseup', (evt)=>{
    if (draggingNode) {
        pushHistory('move node');
    }
    draggingNode = null;
    if (draggingCanvas) {
        draggingCanvas = false; lastPan = null;
    }
    if (selectedEdge && typeof selectedEdge.draggingControl === 'number') {
        delete selectedEdge.draggingControl;
        pushHistory('move control point');
    }
});

// wheel for zoom (Ctrl+wheel for faster)
canvas.addEventListener('wheel', (evt)=>{
    evt.preventDefault();
    const delta = -evt.deltaY;
    const zoomFactor = (delta>0) ? 1.08 : 0.925;
    // zoom centered at mouse
    const rect = canvas.getBoundingClientRect();
    const mx = evt.clientX - rect.left, my = evt.clientY - rect.top;
    const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
    // apply
    scale *= zoomFactor;
    // keep reasonable bounds
    scale = Math.max(0.2, Math.min(4, scale));
    offsetX = mx - wx*scale;
    offsetY = my - wy*scale;
    draw();
}, { passive: false });

// pick edge by proximity (approximate)
function pickEdgeNearby(x,y) {
    let best = null;
    edges.forEach(edge=>{
        const a = findNodeById(edge.a), b = findNodeById(edge.b);
        if (!a || !b) return;
        // if control points, get polyline points
        const pts = [a, ...(edge.controlPoints||[]), b];
        for (let i=1;i<pts.length;i++){
            const p0 = pts[i-1], p1 = pts[i];
            const d = pointToSegmentDistance(x,y,p0.x,p0.y,p1.x,p1.y);
            if (d < 10/scale) {
                if (!best || d < best.d) best = { edge, d };
            }
        }
    });
    return best ? best.edge : null;
}
function pointToSegmentDistance(px,py,x1,y1,x2,y2) {
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A*C + B*D;
    const len_sq = C*C + D*D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param*C; yy = y1 + param*D; }
    return Math.hypot(px-xx, py-yy);
}

// Duplicate name when needed
function duplicatename(node) {
    node.name = node.name + '_copy';
    while (nodes.some(n=>n.name === node.name)) node.name += '_1';
}

// Parse JS (2B) - Simple parser to extract GraphNode and addBidirectionalNeighbor usage
function parseGraphDatabaseJS(jsText) {
    // First try to find GraphNode(...) constructions
    // RegExp matches: new GraphNode('name', 'type', 123, 456)
    const nodeRegex = /new\s+GraphNode\s*\(\s*['"]([^'"]+)['"]\s*,\s*['"]([^'"]+)['"]\s*,\s*([0-9\.]+)\s*,\s*([0-9\.]+)\s*\)/g;
    const idMap = {}; // name -> assigned id
    nodes = [];
    edges = [];
    let match;
    while ((match = nodeRegex.exec(jsText)) !== null) {
        const [raw, name, type, xs, ys] = match;
        const x = parseFloat(xs), y = parseFloat(ys);
        const id = genId('n');
        nodes.push({ id, name, type, x, y });
        idMap[name] = id;
    }
    // Now parse addBidirectionalNeighbor calls of form: a.addBidirectionalNeighbor(b);
    // We'll capture tokens that look like "name.addBidirectionalNeighbor(name2)"
    const edgeRegex = /([A-Za-z0-9_\- ]+)\.addBidirectionalNeighbor\s*\(\s*([A-Za-z0-9_\- ]+)\s*\)/g;
    // But the variables in the JS might be identifiers (not string names). So also try to capture patterns where the code used variables
    // Safer approach: look for patterns like: <identifier>.addBidirectionalNeighbor(<identifier>);
    const identEdgeRegex = /([A-Za-z0-9_\$\_]+)\.addBidirectionalNeighbor\s*\(\s*([A-Za-z0-9_\$\_]+)\s*\)\s*;/g;
    // Try to map variable identifiers to names by finding "<identifier> = new GraphNode('name', ...);"
    const varAssignRegex = /([A-Za-z0-9_\$\_]+)\s*=\s*new\s+GraphNode\s*\(\s*['"]([^'"]+)['"]/g;
    const varToName = {};
    let vmatch;
    while ((vmatch = varAssignRegex.exec(jsText)) !== null) {
        varToName[vmatch[1]] = vmatch[2];
    }
    let ematch;
    while ((ematch = identEdgeRegex.exec(jsText)) !== null) {
        const left = ematch[1], right = ematch[2];
        const leftName = varToName[left] || left;
        const rightName = varToName[right] || right;
        if (idMap[leftName] && idMap[rightName]) {
            const eid = genId('e');
            edges.push({ id: eid, a: idMap[leftName], b: idMap[rightName], controlPoints: [] });
        }
    }
    // Also try literal name matches (rare)
    while ((ematch = edgeRegex.exec(jsText)) !== null) {
        const l = ematch[1].trim(), r = ematch[2].trim();
        // remove trailing dot if present
        const ln = l.replace(/\.+$/,'');
        const rn = r.replace(/\.+$/,'');
        if (idMap[ln] && idMap[rn]) {
            const eid = genId('e');
            edges.push({ id: eid, a: idMap[ln], b: idMap[rn], controlPoints: [] });
        }
    }
    // assign counters based on scanned nodes
    counters = {walkway:0, building:0, gate:0};
    nodes.forEach(n => {
        if (n.type === 'walkway') counters.walkway++;
        if (n.type === 'building') counters.building++;
        if (n.type === 'gate') counters.gate++;
    });
    pushHistory('imported JS');
    draw();
    updateStatus('Parsed JS import — nodes: ' + nodes.length);
}

// Export JS
function exportAsJS() {
    let out = "// Exported by graph_editor_full.html\n";
    out += "// Nodes\n";
    nodes.forEach(n=>{
        out += `const ${sanitizeName(n.name)} = new GraphNode('${n.name}', '${n.type}', ${Math.round(n.x)}, ${Math.round(n.y)});\n`;
    });
    out += "\n// Edges\n";
    edges.forEach(e=>{
        const a = findNodeById(e.a);
        const b = findNodeById(e.b);
        if (!a || !b) return;
        out += `${sanitizeName(a.name)}.addBidirectionalNeighbor(${sanitizeName(b.name)});\n`;
        // if controlPoints present, add code to create them (optional)
        if (e.controlPoints && e.controlPoints.length) {
            out += `// Edge ${a.name} <-> ${b.name} has ${e.controlPoints.length} control points (not serialized to GraphNode)\n`;
        }
    });
    return out;
}
function sanitizeName(n) {
    return n.replace(/[^A-Za-z0-9_]/g, '_');
}

function exportAsJSON() {
    return JSON.stringify({ nodes, edges }, null, 2);
}

// UI bindings
document.getElementById('btnAdd').onclick = ()=> { setMode('addNode'); }
document.getElementById('btnEdge').onclick = ()=> { setMode('addEdge'); }
document.getElementById('btnMove').onclick = ()=> { setMode('moveNode'); }
document.getElementById('btnEditEdge').onclick = ()=> { setMode('editEdge'); }
document.getElementById('btnDelete').onclick = ()=> { setMode('delete'); }
document.getElementById('btnUndo').onclick = ()=> undo();
document.getElementById('btnRedo').onclick = ()=> redo();
document.getElementById('btnExportJS').onclick = ()=> downloadFile('graph_export.js', exportAsJS());
document.getElementById('btnExportJSON').onclick = ()=> downloadFile('graph_export.json', exportAsJSON());
document.getElementById('btnImportJS').onclick = ()=> {
    const txt = document.getElementById('importArea').value.trim();
    if (!txt) { alert('Paste your graphDatabase.js contents into the textarea then click Parse & Import.'); return; }
    parseGraphDatabaseJS(txt);
};
document.getElementById('btnParseJS').onclick = ()=> {
    const txt = document.getElementById('importArea').value.trim();
    if (!txt) { alert('Paste JS into the textarea.'); return; }
    parseGraphDatabaseJS(txt);
};
document.getElementById('btnLoadJSON').onclick = ()=> {
    try {
        const obj = JSON.parse(document.getElementById('importArea').value);
        if (!obj.nodes) throw new Error('JSON must contain nodes and edges');
        nodes = obj.nodes; edges = obj.edges || [];
        pushHistory('loaded JSON');
        draw();
    } catch(e) {
        alert('Invalid JSON: ' + e.message);
    }
};

document.getElementById('toggleGrid').onclick = ()=> { showGrid = !showGrid; draw(); };
document.getElementById('toggleSnap').onclick = ()=> { hardSnap = !hardSnap; document.getElementById('toggleSnap').textContent = 'Hard Snap: ' + (hardSnap?'ON':'OFF'); };
document.getElementById('toggleLabels').onclick = ()=> { showLabels = !showLabels; document.getElementById('toggleLabels').textContent = (showLabels?'Hide Labels (H)':'Show Labels (H)'); draw(); };

document.getElementById('zoomIn').onclick = ()=> { scale *= 1.12; draw(); }
document.getElementById('zoomOut').onclick = ()=> { scale *= 0.9; draw(); }

function setMode(m) {
    mode = m;
    updateStatus('Mode: ' + m);
}

// keyboard shortcuts (5B)
window.addEventListener('keydown', (e)=>{
    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); return; }
    if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); return; }
    if (e.ctrlKey && e.key.toLowerCase() === 's') { e.preventDefault(); downloadFile('graph_export.js', exportAsJS()); return; }
    if (e.key.toLowerCase() === 'a') { setMode('addNode'); return; }
    if (e.key.toLowerCase() === 'e') { setMode('addEdge'); return; }
    if (e.key.toLowerCase() === 'm') { setMode('moveNode'); return; }
    if (e.key.toLowerCase() === 'g') { showGrid = !showGrid; draw(); return; }
    if (e.key.toLowerCase() === 'h') { showLabels = !showLabels; draw(); return; }
    if (e.key.toLowerCase() === 'r') { // rename selected
        if (!selectedNode) { updateStatus('Click a node to select (Move mode) then press R to rename'); return; }
        const newName = prompt('New name for node', selectedNode.name);
        if (newName) { selectedNode.name = newName; pushHistory('rename'); draw(); }
    }
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
        // nudge selected node
        if (selectedNode) {
            let dx=0, dy=0;
            if (e.key==='ArrowUp') dy = -2;
            if (e.key==='ArrowDown') dy = 2;
            if (e.key==='ArrowLeft') dx = -2;
            if (e.key==='ArrowRight') dx = 2;
            selectedNode.x += dx; selectedNode.y += dy;
            pushHistory('nudge');
            draw();
        }
    }
    // WASD pan
    if (e.key.toLowerCase() === 'w') { offsetY += 20; draw(); }
    if (e.key.toLowerCase() === 's' && !e.ctrlKey) { offsetY -= 20; draw(); }
    if (e.key.toLowerCase() === 'a') { offsetX += 20; draw(); }
    if (e.key.toLowerCase() === 'd') { offsetX -= 20; draw(); }
});

// helper to download
function downloadFile(name, content) {
    const blob = new Blob([content], {type:'text/plain'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = name; a.click();
}

// click-to-select nodes when in move mode
canvas.addEventListener('dblclick', (evt)=>{
    const p = toCanvasCoords(evt.clientX, evt.clientY);
    const n = findNodeNear(p.x,p.y);
    if (n) {
        selectedNode = n;
        updateStatus('Selected: ' + n.name);
    }
});

// click on canvas to add control point when in editEdge mode and an edge selected
canvas.addEventListener('click', (evt)=>{
    const p = toCanvasCoords(evt.clientX, evt.clientY);
    if (mode === 'editEdge' && selectedEdge) {
        // add control point at clicked location
        selectedEdge.controlPoints = selectedEdge.controlPoints || [];
        selectedEdge.controlPoints.push({ x: p.x, y: p.y });
        pushHistory('add control point');
        draw();
    }
});

// initialize history with empty baseline
pushHistory('initial');

updateStatus('Ready.');

// Resize on window change
window.addEventListener('resize', ()=> { draw(); });

</script>

</body>
</html>
